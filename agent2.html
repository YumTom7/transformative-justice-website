<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Case Connector – Agent</title>
<meta name="robots" content="noindex,nofollow" />
<style>
  :root{ --bg:#071c2b; --ink:#d9ecff; --fade:1900ms;
         /* tweak these 2 numbers to line the mouth up with your photo */
         --mouth-x:50%; --mouth-y:62%;
  }
  html,body{ height:100%; margin:0; background:var(--bg); color:var(--ink);
    font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
  .stage{ position:relative; height:100%; overflow:hidden; }

  /* Particle dots */
  #dots{ position:absolute; inset:0; display:block; }

  /* Image reveal */
  .agent{ position:absolute; inset:0; display:grid; place-items:center; pointer-events:none; }
  .face{ width:min(86vmin,720px); max-width:96%;
         opacity:0; filter: blur(16px) saturate(1.1) drop-shadow(0 0 26px rgba(74,196,255,.28));
         transition: opacity var(--fade) ease, filter var(--fade) ease; }
  .started .face{ opacity:1; filter: blur(0); }

  /* Mouth overlay (SVG) – positioned over the face using --mouth-x/--mouth-y */
  .mouthWrap{ position:absolute; left:var(--mouth-x); top:var(--mouth-y);
              transform:translate(-50%,-50%); width:min(86vmin,720px); pointer-events:none; opacity:0;
              transition: opacity 600ms ease; }
  .started .mouthWrap{ opacity:1; }
  svg{ width:100%; height:auto; }
  #mouth { fill:#72d4ff4d; stroke:#c7ecff; stroke-width:2.5;
           filter:drop-shadow(0 0 10px rgba(111,210,255,.6));
           transform-origin:50% 50%; transition: transform 110ms ease; }
  /* viseme-ish shapes controlled by data-shape attr */
  #mouth[data-shape="closed"] { transform: scaleX(1.0) scaleY(0.25); }
  #mouth[data-shape="AA"]     { transform: scaleX(1.0) scaleY(2.0);  }  /* ah */
  #mouth[data-shape="O"]      { transform: scaleX(0.7) scaleY(1.4);  }  /* oh */
  #mouth[data-shape="E"]      { transform: scaleX(1.7) scaleY(0.55); }  /* ee */
  #mouth.pulse { animation: pulse 150ms ease-in-out; }
  @keyframes pulse{ 0%{transform:translateZ(0) scale(1,1)} 50%{transform:translateZ(0) scale(1.02,1.12)} 100%{transform:translateZ(0) scale(1,1)} }

  /* Begin gate (needed for audio gesture on mobile) */
  .gate{ position:absolute; inset:0; display:grid; place-items:center;
         background:rgba(7,28,43,.55); backdrop-filter:blur(2px); transition:opacity .35s; }
  .gate.hidden{ opacity:0; pointer-events:none; }
  .gate button{ appearance:none; border:0; border-radius:14px; padding:14px 20px; font-weight:700;
                background:#3aa7ff; color:#071c2b; cursor:pointer; box-shadow:0 10px 24px rgba(0,0,0,.35); }

  /* Optional voice picker (appears top-right) */
  #voicePicker{ position:absolute; top:10px; right:10px; background:rgba(0,0,0,.35); color:#fff;
                border:1px solid rgba(255,255,255,.3); border-radius:8px; padding:6px 8px; display:none; }

  @media (prefers-reduced-motion: reduce){ .face{transition:none} }
</style>
</head>
<body>
<select id="voicePicker" aria-label="Choose voice"></select>

<div class="stage" id="stage">
  <canvas id="dots" aria-hidden="true"></canvas>

  <div class="agent">
    <img id="face" class="face" src="assets/agent.jpg" alt="Agent face" />
    <div class="mouthWrap" aria-hidden="true">
      <!-- 1000x1000 viewBox makes positioning simple; mouth ellipse sits at center -->
      <svg viewBox="0 0 1000 1000" preserveAspectRatio="xMidYMid meet">
        <g transform="translate(500,500)">
          <ellipse id="mouth" rx="90" ry="20" data-shape="closed"></ellipse>
        </g>
      </svg>
    </div>
  </div>

  <div class="gate" id="gate" role="dialog" aria-modal="true" aria-label="Begin">
    <button id="begin">Tap to begin</button>
  </div>
</div>

<script>
/*** ======= CONFIG ======= ***/
const SCRIPT_TEXT =
  "Hi, welcome to Case Connector. I am here to serve. I know this isn’t an easy moment, and you may be experiencing mixed feelings. I am here to help. To do that, I need to get to know you better. Please scan the code to get started.";

// If you know the exact voice name on your device, set it here to force it.
// Examples: "Google UK English Male", "Microsoft Guy Online (Natural) - English (United States)", "Alex"
const FORCE_VOICE_NAME = "";

// Prefer male voices by these patterns if FORCE_VOICE_NAME isn't set:
const MALE_PATTERNS = [
  /Google UK English Male/i, /Google US English/i, /Microsoft (Guy|Christopher|Eric|Ryan|Steffan)/i,
  /\bAlex\b/i, /\bDaniel\b/i, /\bGeorge\b/i, /\bMale\b/i
];
/*** ======================= ***/

/* ---------- Particle field ---------- */
const canvas = document.getElementById('dots'), ctx = canvas.getContext('2d');
let W,H, dots=[], converge=false;
function size(){ W=canvas.width=innerWidth; H=canvas.height=innerHeight; }
addEventListener('resize', size); size();
function initDots(n=Math.min(1000, Math.floor((W*H)/4500))){
  dots = Array.from({length:n}, () => ({
    x: Math.random()*W, y: Math.random()*H,
    r: Math.random()*1.8+0.5,
    vx: (Math.random()*2-1)*0.22, vy: (Math.random()*2-1)*0.22
  }));
}
initDots();
function tick(){
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#071c2b';
  ctx.fillRect(0,0,W,H);
  ctx.globalAlpha = converge ? 0.13 : 1.0;
  ctx.fillStyle = "rgba(255,255,255,0.12)";
  for(const d of dots){
    d.x+=d.vx; d.y+=d.vy;
    if(d.x<0||d.x>W) d.vx*=-1;
    if(d.y<0||d.y>H) d.vy*=-1;
    ctx.beginPath(); ctx.arc(d.x,d.y,d.r,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;
  requestAnimationFrame(tick);
}
tick();

/* ---------- UI ---------- */
const stage = document.getElementById('stage');
const gate  = document.getElementById('gate');
const face  = document.getElementById('face');
const mouth = document.getElementById('mouth');
const picker = document.getElementById('voicePicker');

function imgReadyOrTimeout(img, ms=900){
  if (img.complete && img.naturalWidth>0) return Promise.resolve();
  return new Promise(res=>{
    const done=()=>{cleanup();res();};
    const t=setTimeout(done, ms);
    const onl=()=>done(), one=()=>done();
    function cleanup(){clearTimeout(t); img.removeEventListener('load',onl); img.removeEventListener('error',one);}
    img.addEventListener('load',onl,{once:true}); img.addEventListener('error',one,{once:true});
  });
}

document.getElementById('begin').addEventListener('click', async ()=>{
  await imgReadyOrTimeout(face);     // don’t block forever if the image is missing
  converge = true;                    // dim dots → reveal face
  stage.classList.add('started');
  gate.classList.add('hidden');
  await speakWithMouth(SCRIPT_TEXT).catch(()=>{});
});

/* ---------- Speech + lip motion ---------- */
let selectedVoice = null;
let fallbackPulseTimer = null;

function listVoices(){ try { return speechSynthesis.getVoices() || []; } catch { return []; } }

function pickVoice(voices){
  if (FORCE_VOICE_NAME){
    const exact = voices.find(v => v.name === FORCE_VOICE_NAME);
    if (exact) return exact;
  }
  for (const rx of MALE_PATTERNS){
    const hit = voices.find(v => rx.test(`${v.name} ${v.voiceURI||""}`) && /en/i.test(v.lang||""));
    if (hit) return hit;
  }
  const labeledMale = voices.find(v => /en/i.test(v.lang||"") && /male/i.test(`${v.name} ${v.voiceURI||""}`));
  if (labeledMale) return labeledMale;
  const english = voices.find(v => /en/i.test(v.lang||""));
  return english || voices[0] || null;
}

function buildPicker(voices){
  if (!voices.length) return;
  picker.style.display = 'block'; // show small selector so you can force a male voice
  picker.innerHTML = voices.map(v => `<option ${selectedVoice && selectedVoice.name===v.name?'selected':''}>${v.name} :: ${v.lang}</option>`).join('');
  picker.onchange = () => {
    const [name] = picker.value.split(' :: ');
    const v = voices.find(v => v.name===name);
    if (v) selectedVoice = v;
  };
}

function setMouthShape(shape){ mouth.setAttribute('data-shape', shape); }
function pulse(){ mouth.classList.remove('pulse'); void mouth.offsetWidth; mouth.classList.add('pulse'); }

/* Guess a viseme from the current word’s vowels */
function guessShapeForWord(word){
  const w = (word||"").toLowerCase();
  if (/[oou]/.test(w)) return "O";
  if (/[ei]/.test(w))  return "E";
  if (/[a]/.test(w))   return "AA";
  return "AA";
}

async function speakWithMouth(text){
  if (!('speechSynthesis' in window)) return;

  // Wait for voices to load (Chrome quirk)
  await new Promise(res=>{
    const voices = listVoices();
    if (voices.length) return res();
    speechSynthesis.addEventListener('voiceschanged', res, {once:true});
  });

  const voices = listVoices();
  if (!selectedVoice) selectedVoice = pickVoice(voices);
  buildPicker(voices);

  const utter = new SpeechSynthesisUtterance(text);
  if (selectedVoice) utter.voice = selectedVoice;
  // Tilt towards a male timbre even if voice is neutral
  utter.rate = 1.0; utter.pitch = 0.9; utter.volume = 1.0;

  // Continuous fallback motion (in case boundary events are sparse on some browsers)
  function startFallback(){
    clearInterval(fallbackPulseTimer);
    fallbackPulseTimer = setInterval(()=>{ pulse(); }, 180);
  }
  function stopFallback(){ clearInterval(fallbackPulseTimer); fallbackPulseTimer = null; }

  // Word-boundary → choose shape from the actual word
  utter.onboundary = (e)=>{
    if (e.name === "word" && e.charIndex != null){
      const upTo = text.slice(0, e.charIndex);
      const words = upTo.split(/\s+/);
      const current = text.slice(e.charIndex).split(/\s+/)[0];
      setMouthShape(guessShapeForWord(current));
      pulse();
    }
  };
  utter.onstart = ()=>{ setMouthShape("AA"); startFallback(); };
  utter.onend   = ()=>{ stopFallback(); setMouthShape("closed"); mouth.classList.remove('pulse'); };

  speechSynthesis.cancel();
  speechSynthesis.speak(utter);
}
</script>
</body>
</html>
