import io, os, tempfile, time, json, base64, subprocess
from typing import Dict
from fastapi import FastAPI, UploadFile, File, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from openai import OpenAI

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "")
client = OpenAI(api_key=OPENAI_API_KEY)

app = FastAPI()
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_methods=["*"], allow_headers=["*"])
JOBS: Dict[str, Dict] = {}  # in-memory job table for the pilot

def ffmpeg_normalize(in_path, out_path):
    # mono 16kHz WAV
    cmd = ["ffmpeg", "-y", "-i", in_path, "-ac", "1", "-ar", "16000", out_path]
    subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)

def transcribe(path):
    # Whisper (predictable cost) — switch model if you like
    with open(path, "rb") as f:
        tr = client.audio.transcriptions.create(
            model="whisper-1",
            file=f,
            response_format="verbose_json"  # segments w/ timestamps
        )
    return tr  # dict-like

def simple_detectors(transcript_json):
    flags = []
    meta_phrases = ["you know what I mean", "don’t say that", "dont say that", "they're listening", "they are listening", "you know"]
    for seg in transcript_json.get("segments", []):
      text = (seg.get("text") or "").lower()
      start = float(seg.get("start", 0.0)); end = float(seg.get("end", 0.0))
      # hesitation via long duration per few words (very naive)
      words = max(1, len(text.split()))
      dur = max(0.1, end - start)
      hes_score = dur/words
      reasons = []
      if any(p in text for p in meta_phrases):
          reasons.append("META_EVASION")
      if hes_score > 0.9:  # crude first pass
          reasons.append("HESITATION_SPIKE")
      if reasons:
          flags.append({
              "span_s": {"start": start, "end": end},
              "reasons": reasons,
              "flag_score": round(min(0.99, 0.4 + (hes_score-0.9)*0.4 + 0.2*len(reasons)), 2)
          })
    return flags

def render_report_html(case_id, summary):
    # very simple printable HTML; you can swap in the nicer template later
    rows = []
    for f in summary["flags"][:6]:
        rows.append(f"""
        <div style="border-left:4px solid #c00;padding-left:8px;margin:10px 0;">
          <div><b>Reasons:</b> {", ".join(f["reasons"])} | <b>flag_score</b>={f["flag_score"]}</div>
          <div><b>Span:</b> {f['span_s']['start']:.1f}s → {f['span_s']['end']:.1f}s</div>
        </div>
        """)
    body = "\n".join(rows) or "<i>No flags found (pilot detectors are conservative).</i>"
    now = time.strftime("%Y-%m-%d %H:%M:%S")
    return f"""
<!doctype html><html><head><meta charset="utf-8">
<title>Triage Report — {case_id}</title>
<style>body{{font-family:system-ui,Segoe UI,Arial;margin:20px}} .btn{{padding:8px 12px;border-radius:8px;border:1px solid #111;background:#111;color:#fff;cursor:pointer}}</style>
</head><body>
<h1>Triage Report — {case_id}</h1>
<div>Generated: {now} · Policy: Zero-Retention · Model: whisper-1</div>
<hr/>
<h3>Flagged Spans</h3>
{body}
<hr/>
<button class="btn" onclick="window.print()">Print / Save</button>
</body></html>
"""

@app.post("/enqueue")
async def enqueue(file: UploadFile = File(...), case_id: str = "CASE-PILOT"):
    job_id = f"JOB-{int(time.time()*1000)}"
    JOBS[job_id] = {"state": "processing"}
    # process immediately (no queue) in a temp dir; zero-retention discipline
    with tempfile.TemporaryDirectory() as td:
        src = os.path.join(td, file.filename)
        with open(src, "wb") as out:
            out.write(await file.read())
        norm = os.path.join(td, "norm.wav")
        ffmpeg_normalize(src, norm)
        tr = transcribe(norm)
        flags = simple_detectors(tr)
        summary = {
            "schema_version":"1.0",
            "case_id": case_id,
            "run_id": job_id,
            "time_range": {"start":"", "end":""},
            "profile": "Obstruction",
            "codebook_version": "v0",
            "flags": flags,
            "trendlines": [],
            "policy": {"retention":"NONE"}
        }
        html = render_report_html(case_id, summary)
        JOBS[job_id] = {"state":"ready", "report_html": html, "summary_json": summary}
    return {"job_id": job_id}

@app.get("/status")
def status(job_id: str = Query(...)):
    j = JOBS.get(job_id, {"state":"missing"})
    # return report inline (simple for pilot)
    if j.get("state") == "ready":
        return {"state":"ready", "report_html": j["report_html"], "summary_json": j["summary_json"]}
    return {"state": j.get("state", "missing")}
